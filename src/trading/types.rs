//! Trading types and structures

use crate::polymarket::types::{Side, TokenType};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// Trading signal generated by strategies
#[derive(Debug, Clone)]
pub struct Signal {
    pub signal_type: SignalType,
    pub market_id: String,
    pub token_type: TokenType,
    pub suggested_price: Decimal,
    pub suggested_size: Decimal,
    pub confidence: Decimal,
    pub reason: String,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SignalType {
    /// Pure hedging arbitrage (Yes+No < threshold)
    HedgeEntry,
    /// Exit hedge position
    HedgeExit,
    /// Latency arbitrage (Binance move detected)
    LatencyEntry,
    /// Average down on existing position
    AverageDown,
    /// Stop loss exit
    StopLoss,
}

impl std::fmt::Display for SignalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SignalType::HedgeEntry => write!(f, "HEDGE_ENTRY"),
            SignalType::HedgeExit => write!(f, "HEDGE_EXIT"),
            SignalType::LatencyEntry => write!(f, "LATENCY_ENTRY"),
            SignalType::AverageDown => write!(f, "AVG_DOWN"),
            SignalType::StopLoss => write!(f, "STOP_LOSS"),
        }
    }
}

/// Active hedge trade tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HedgeTrade {
    pub id: String,
    pub market_id: String,
    pub asset: String,

    // Leg 1: Initial position
    pub leg1: TradeLeg,

    // Leg 2: Hedge position
    pub leg2: Option<TradeLeg>,

    pub status: HedgeStatus,
    pub entry_reason: String,
    pub created_at: DateTime<Utc>,
    pub timeout_at: DateTime<Utc>,
    pub closed_at: Option<DateTime<Utc>>,
    pub pnl: Option<Decimal>,
    pub is_simulated: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradeLeg {
    pub order_id: Option<String>,
    pub token_id: String,
    pub token_type: TokenType,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub filled_size: Decimal,
    pub status: LegStatus,
    pub filled_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum LegStatus {
    Pending,
    Open,
    PartiallyFilled,
    Filled,
    Cancelled,
    Failed,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum HedgeStatus {
    /// Leg 1 order placed, waiting for fill
    Leg1Pending,
    /// Leg 1 filled, waiting to place Leg 2
    Leg1Filled,
    /// Leg 2 order placed, waiting for fill
    Leg2Pending,
    /// Both legs filled - complete hedge
    Complete,
    /// Hedge closed with profit
    ClosedProfit,
    /// Hedge closed with loss
    ClosedLoss,
    /// Timed out before completion
    TimedOut,
    /// Manually cancelled
    Cancelled,
}

impl std::fmt::Display for HedgeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            HedgeStatus::Leg1Pending => write!(f, "LEG1_PENDING"),
            HedgeStatus::Leg1Filled => write!(f, "LEG1_FILLED"),
            HedgeStatus::Leg2Pending => write!(f, "LEG2_PENDING"),
            HedgeStatus::Complete => write!(f, "COMPLETE"),
            HedgeStatus::ClosedProfit => write!(f, "CLOSED_PROFIT"),
            HedgeStatus::ClosedLoss => write!(f, "CLOSED_LOSS"),
            HedgeStatus::TimedOut => write!(f, "TIMED_OUT"),
            HedgeStatus::Cancelled => write!(f, "CANCELLED"),
        }
    }
}

/// Position tracking per market
#[derive(Debug, Clone, Default)]
pub struct Position {
    pub market_id: String,
    pub yes_shares: Decimal,
    pub no_shares: Decimal,
    pub yes_avg_price: Decimal,
    pub no_avg_price: Decimal,
    pub total_cost: Decimal,
    pub unrealized_pnl: Decimal,
    pub realized_pnl: Decimal,
}

impl Position {
    pub fn new(market_id: String) -> Self {
        Self {
            market_id,
            ..Default::default()
        }
    }

    pub fn net_exposure(&self) -> Decimal {
        self.yes_shares - self.no_shares
    }

    pub fn is_hedged(&self) -> bool {
        self.yes_shares > Decimal::ZERO && self.no_shares > Decimal::ZERO
    }

    pub fn total_shares(&self) -> Decimal {
        self.yes_shares + self.no_shares
    }
}

/// Daily trading statistics
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct DailyStats {
    pub date: String,
    pub trades_count: u32,
    pub wins: u32,
    pub losses: u32,
    pub total_volume: Decimal,
    pub gross_pnl: Decimal,
    pub fees_paid: Decimal,
    pub net_pnl: Decimal,
    pub best_trade: Option<Decimal>,
    pub worst_trade: Option<Decimal>,
    pub consecutive_losses: u32,
    pub max_consecutive_losses: u32,
}

impl DailyStats {
    pub fn win_rate(&self) -> Decimal {
        if self.trades_count == 0 {
            return Decimal::ZERO;
        }
        Decimal::from(self.wins) / Decimal::from(self.trades_count) * Decimal::new(100, 0)
    }

    pub fn avg_pnl(&self) -> Decimal {
        if self.trades_count == 0 {
            return Decimal::ZERO;
        }
        self.net_pnl / Decimal::from(self.trades_count)
    }
}

/// Risk state for circuit breaker
#[derive(Debug, Clone)]
pub struct RiskState {
    pub daily_loss: Decimal,
    pub daily_exposure: Decimal,
    pub consecutive_losses: u32,
    pub in_cooldown: bool,
    pub cooldown_until: Option<DateTime<Utc>>,
    pub is_paused: bool,
    pub pause_reason: Option<String>,
}

impl Default for RiskState {
    fn default() -> Self {
        Self {
            daily_loss: Decimal::ZERO,
            daily_exposure: Decimal::ZERO,
            consecutive_losses: 0,
            in_cooldown: false,
            cooldown_until: None,
            is_paused: false,
            pause_reason: None,
        }
    }
}
